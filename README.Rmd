---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# enRUVseq

<!-- badges: start -->

<!-- badges: end -->

The goal of `enRUVseq` is to perform normalization on RNA-seq including enrichment (NAD-RNA-seq) using spike-in.

The main functions for normalizing enrichment variation between samples were inspired by [RUVSeq](https://github.com/drisso/RUVSeq).

## Installation

You can install the development version of enRUVseq from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("thereallda/enRUVseq")
```

## Workflow

```{r example, warning=FALSE, message=FALSE}
library(enRUVseq)
library(tidyverse)
library(edgeR)
library(paintingr)
library(patchwork)
library(SummarizedExperiment)
```

### Load data

Metadata including sample information.

```{r}
meta <- read.csv('data-raw/metadata.csv', comment.char = '#')
meta
```

NAD-RNA-Sequencing data, with genes in rows and samples in columns.

```{r}
counts.df <- read.csv('data-raw/Counts.csv', row.names = 1)
counts.df[1:3,]
```

### Filtering low-expressed genes

```{r}
spikeInPrefix <- '^FB'
keep <- filterByExpr(counts.df, group = meta$condition)
counts_keep <- counts.df[keep,]
dim(counts.df); dim(counts_keep)
```

### Create Enone object

Use "input.id" and "enrich.id" to specify the id of input and enrich library, which should be the same as `group`. If `group` is `c("High.Input", "High.Enrich",...)`, then `input.id` = 'Input' and `enrich.id` = 'Enrich'.

`synthetic.id` is a vector specify the ids of synthetic RNA, if included. 

```{r}
enrich_group <- gsub(".*\\.", "", meta$condition)

Enone <- createEnone(data = counts_keep,
                     bio.group = meta$condition,
                     enrich.group = enrich_group,
                     batch.group = NULL,
                     spike.in.prefix = spikeInPrefix,
                     synthetic.id = c('Syn1','Syn2'),
                     input.id = "Input",
                     enrich.id = "Enrich"
                     )
Enone
```

Raw counts (sample + spike-in) can be accessed with 

```{r}
assay(Enone)[1:3,];dim(assay(Enone))
```

Sample information is stored in `colData` 

```{r}
colData(Enone)
```

### Perform normalization and assessment

Normalization and assessment can be achieved by wrapper function `enONE`

```{r}
Enone <- enONE(Enone, 
               ruv.norm = TRUE, ruv.k = 3,
               pam_krange = 2:6, pc_k = 3
               )
```

Normalized counts are stored in `counts` slot in which `sample` slot holds the counts from sample and `spike_in` slot for spike-in counts. 

```{r}
names(Enone@counts$sample)
```

Check the performance of normalization

```{r}
Enone@enone_score
```

PCA biplot

if batch not provided, preclude `BATCH_SIL` column 

```{r, fig.width=10, fig.height=10}
pca.nsp.eval <- prcomp(Enone@enone_score[,-c(3, 9)], scale = TRUE)
ggPCA_Biplot(pca.nsp.eval, performance_score = Enone@enone_score$SCORE)
```

save

```{r,eval=FALSE}
save(Enone, file='data/NormAssess.rda')
```

### The best performance

```{r}
# select the best normalization
best.norm <- rownames(Enone@enone_score[1,])
best.norm.data <- Counts(Enone, slot = 'sample', method = best.norm)
best.norm.factors <- getFactor(Enone, slot = 'sample', method = best.norm)
best.norm

```

### Effect of normalization

we use PCA to visualize the counts from non-spike-in samples before and after the normalization.

```{r,fig.width=8, fig.height=5}
counts_nsp <- counts_keep[grep(spikeInPrefix, rownames(counts_keep), invert = TRUE), ]
samples_name <- paste(meta$condition, meta$replicate, sep='.')
p1 <- ggPCA(log1p(counts_nsp), 
            group = meta$condition,
            label = samples_name, vst.norm = FALSE) + ggtitle('Before normalization')
p2 <- ggPCA(log1p(best.norm.data), 
            group = meta$condition,
            label = samples_name, vst.norm = FALSE) + ggtitle('After normalization')
p1 + p2
```

### FindEnrichment

You can find enriched genes by `FindEnrichment`.

Enriched genes are saved at slots `Enone@enrichment` (all) and `Enone@enrichment_filtered` (filtered). 

Default criteria for enriched genes is log2-Fold-Change >= 1 & adjusted p-value < 0.05. 

```{r}
Enone <- FindEnrichment(Enone, slot='sample', method = best.norm, 
                        fc.cutoff = 1, p.cutoff = 0.05)
unlist(lapply(Enone@enrichment_filtered$sample, nrow))
```

Each enrichment table is a `data.frame` with a list of genes as rows, and associated information as columns (GeneID, logFC, p-values, etc.). The following columns are present in the table: 

- `GeneID`: ID of genes. 
- `logFC`: log2 fold-change between enrichment and input samples. Positive values indicate that the gene is more highly enriched in the enrichment group.
- `logCPM`: log2 CPM (counts per million) of the average expression of all samples. 
- `LR`: Likelihood ratio of the likelihood ratio test. 
- `PValue`: p-value from the likelihood ratio test. 
- `FDR`: False discovery rate of the p-value, default "BH" method is applied. 

```{r}
head(Enone@enrichment_filtered$sample$High.Enrich_High.Input)
```

Reduce list of enrichment and visualize with violin-box plot.

```{r}
nad.sig.ls <- Enone@enrichment_filtered$sample
nad_df1 <- reduceRes(nad.sig.ls, fc.col = 'logFC')
nad_df1$Group <- gsub('\\..*', '', nad_df1$Group)
nad_df1$Group <- factor(nad_df1$Group, levels = unique(nad_df1$Group))
bxp1 <- BetweenStatPlot(nad_df1, x='Group', y='logFC', color='Group', step.increase = 0.6) + ggtitle('Human')
bxp1
```
