---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# enRUVseq

<!-- badges: start -->

<!-- badges: end -->

The goal of `enRUVseq` is to perform normalization on RNA-seq including enrichment (NAD-RNA-seq) using spike-in.

The main functions for normalizing enrichment variation between samples were inspired by [RUVSeq](https://github.com/drisso/RUVSeq).

## Installation

You can install the development version of enRUVseq from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("thereallda/enRUVseq")
```

## Workflow

```{r example,warning=FALSE,message=FALSE}
library(enRUVseq)
library(tidyverse)
library(edgeR)
library(paintingr)
library(patchwork)
```

### Load data

Metadata including sample information.

```{r}
meta <- read.csv('data-raw/metadata_enRUVg.csv', comment.char = '#')
meta
```

NAD-RNA-Sequencing data, with genes in rows and samples in columns.

```{r}
counts.df <- read.csv('data-raw/Counts_enRUVg.csv', row.names = 1)
counts.df[1:3,]
```

### Filtering low-expressed genes

```{r}
spikeInPrefix <- '^FB'
keep <- filterByExpr(counts.df, group = meta$condition)
counts_keep <- counts.df[keep,]
dim(counts.df); dim(counts_keep)
```

### Perform normalization and assessment

Use "input.id" and "enrich.id" to specify the id of input and enrich library, which should be the same as `group`. If `group` is `c("High.Input", "High.Enrich",...)`, then `input.id` = 'Input' and `enrich.id` = 'Enrich'.

```{r}
ONE_obj <- enONE(counts_keep, group = meta$condition, spike.in.prefix = '^FB',
                 input.id = 'Input', enrich.id = 'Enrich',
                 ruv.norm = TRUE, ruv.k = 3)
```

```{r}
names(ONE_obj)
```

`enONE` return three list,

-   `gene.set` contains the gene id of negative control genes (for normalization) and positive and negative evaluation genes (for assessment).

-   `norm.data.ls` contains all the normalized data.

-   `norm.assessment` contains the normalization assessment results.

check the performance of normalization

```{r}
ONE_obj$norm.assessment$performance
```

PCA biplot

```{r, fig.width=10, fig.height=10}
pca.nsp.eval <- prcomp(ONE_obj$norm.assessment$performance[,-ncol(ONE_obj$norm.assessment$performance)], scale = TRUE)
ggPCA_Biplot(pca.nsp.eval, performance_score = ONE_obj$norm.assessment$performance$PERF_SCORE)
```

save

```{r,eval=FALSE}
save(ONE_obj, file='data/NormAssess.rda')
```

### The best performance

```{r}
# select the best normalization
best.norm <- rownames(ONE_obj$norm.assessment$performance[1,])
best.norm.data <- ONE_obj$norm.data.ls[[best.norm]]
best.norm

```

### Effect of normalization

we use PCA to visualize the counts from non-spike-in samples before and after the normalization.

```{r,fig.width=8, fig.height=5}
counts_nsp <- counts_keep[grep(spikeInPrefix, rownames(counts_keep), invert = TRUE), ]
samples_name <- paste(meta$condition, meta$replicate, sep='.')
p1 <- ggPCA(log1p(counts_nsp), 
            group = meta$condition,
            label = samples_name, vst.norm = FALSE) + ggtitle('Before normalization')
p2 <- ggPCA(log1p(best.norm.data$dataNorm), 
            group = meta$condition,
            label = samples_name, vst.norm = FALSE) + ggtitle('After normalization')
p1 + p2
```

### DE

```{r}
contrast_df <- data.frame(Group1 = unique(grep("Enrich", meta$condition, value = TRUE)),
                          Group2 = unique(grep("Input", meta$condition, value = TRUE)))
de.best.norm <- edgeRDE(counts_nsp[!rownames(counts_nsp) %in% c('Syn1', 'Syn2'),],
                        group = meta$condition,
                        contrast.df = contrast_df,
                        norm.factors = best.norm.data$normFactor, # chose as best norm
                        adjust.factors = best.norm.data$adjustFactor
                        )
```

```{r}
nad_df1 <- reduceRes(de.best.norm$res.sig.ls, fc.col = 'logFC')
nad_df1$Group <- gsub('\\..*', '', nad_df1$Group)
nad_df1$Group <- factor(nad_df1$Group, levels = unique(nad_df1$Group))
bxp1 <- BetweenStatPlot(nad_df1, x='Group', y='logFC', color='Group') + ggtitle('Human')
bxp1
```
